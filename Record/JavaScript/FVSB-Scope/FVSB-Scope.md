# Function Scope VS Block Scope

[이전 글로 이동하기 -> Lexical Scope](../LexicalScope/LexicalScope.md)

### 함수 기반 스코프

스코프는 컨테이너 역할을 하는 버블이고 변수나 함수같은 식별자가 그 안에서 선언된다.<br>

그렇다면 정확히 어떤 것이 새로운 버블을 만들까? 함수만 버블을 만들까? 자바스크립트의 다른 자료 구조는 스코프 버블을 생성하지 못할까?<br>

이에 대한 가장 일반적인 답변은 자바스크립트가 함수 기반 스코프를 사용하기 때문에 각각 선언된 함수는 저마다의 스코프를 가지지만 다른 어떤 자료구조도 자체적인 스코프를 생성하지 않는다는 것이다.<br>

하나의 함수를 보자.<br>

```
function foo(a) {
  var b = 2;

  // some code

  function bar() {
    // ...
  }

  //more code

  var c = 3;
}
```

foo()의 스코프 버블은 식별자 a / b / c 와 bar를 포함한다.<br>
(선언문이 스코프의 어디에 있는지는 중요하지 않다. 스코프 안에 있는 모든 변수와 함수는 그 버블에 속한다.)<br>

bar()도 스코프 버블을 가지고 있다.<br>

글로벌 스코프 역시 스코프 버블을 가지고 있다. -> foo()<br>

a / b / c / bar 모두 foo의 스코프 버블에 속하므로 foo 바깥에서는 이들에게 접근할 수 없다. 따라서 다음과 같은 코드는 호출된 식별자가 글로벌 스코프 내에 없기 때문에 Reference Error를 발생시킨다.<br>
```
bar();
console.log(a, b, c);
```

반대로 이 모든 확인자(a / b / c / bar)는 foo안에서 접근할 수 있고 bar안에서도 접근할 수 있다.<br>

함수 스코프는 모든 변수가 함수에 속하고 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 가지고 있다.<br>

요약 -> 이러한 방법은 자바스크립트의 동적 특성을 살려 완전히 다른 타입의 값을 필요에 따라 가져올 수 있지만 스코프 전체에서 변수가 살아있다는 점 때문에 예상치 못한 문제를 가져올 수도 있다.<br>

### 일반 스코프에 숨기

스코프 전체에서 변수가 살아있다는 점 때문에 우리는 예상치 못한 충돌을 가져올 수 있다.<br>

이것을 피하는 방법은 작성해놓은 코드의 임의의 부분을 함수 선언문으로 감싸는 것이다. -> 이는 해당 코드를 `숨기는` 역할을 한다.<br>

이렇게 코드의 일부를 함수로 선언하면 새로운 스코프 버블이 생성되고 감싸진 코드 안에 있는 변수와 함수 선언문은 더 이상 이전 스코프가 아니라 새로 만들어진 스코프 버블에 묶이게 된다.<br>

달리 말하면 새로운 스코프로 둘러싸는 것은 변수와 함수를 숨길 수 있다는 말이 된다.<br>

스코프를 사용해 숨기는 방식을 사용하는 이유 중 하나는 디자인 원칙 중 하나인 __최소 권한의 원칙__ 를 지키기 위함이다.<br>

이 원칙은 모듈/객체의 API 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 숨겨야 한다는 것이다.<br>

만약 모든 변수와 함수가 글로벌 스코프에 존재한다면 어느 중첩된 하위 스코프에서도 이들을 사용할 수 있다. 하지만 이는 접근할 필요가 없는 많은 변수나 함수들을 노출시키게 된다.<br>

EX)
```
function doSomething(a) {
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b = 1;

doSomething(2); // 15
```
위 코드는 `최소 권한의 원칙`을 지키지 않으며 글로벌 스코프 내에서 모두 접근이 가능하다.<br>

이것을 아래와 같이 `최소 권한의 원칙`을 준수하는 코드로 변경한다.<br>
```
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse(a*2);
  console.log(b*3);
}

doSomething(2); // 15
```
같은 결과를 불러오지만 doSomethingElse스코프가 doSomething스코프 내부에 적절히 숨겨지면서 doSomethingElse는 더 이상 외부에서 접근할 수 없게 되었다.<br>

때문에 doSomething만이 doSomethingElse를 통제할 수 있게 되었다.<br><br>

변수와 함수를 스코프 안에 숨기는 것의 또 다른 장점은 다른 용도로 사용되는 같은 이름의 식별자가 충돌하는 것을 피할 수 있다는 것이다.<br>

물론 겹치는 식별자가 있다면 서로 다른 이름의 식별자로 만들어주는 것도 선택지이지만 프로그램이 커진다면 식별자 하나하나 관리를 하며 충돌이 일어나지 않게 한다는 것을 매우 어려운 일이며 자기도 모르게 같은 식별자 이름을 여러개 만들 상황이 생기기도 할 것이다.<br>

때문에 가장 좋은 방법은 스코프를 사용해 내부에 선언문을 숨기는 것이 가장 좋은 방법이라고 할 수 있다.<br><br>

글로벌 스코프에서 일어나는 2가지 충돌과 해결법을 알아보자.<br>

1. 글로벌 네임스페이스<br>
  내부 비공개 함수와 변수가 적절하게 숨겨지지 않은 라이브러리를 한 프로그램에 여러 개 불러오면 라이브러리들은 쉽게 충돌한다.<br><br>
  이러한 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 선언한다.<br><br>
  이후 객체는 해당 라이브러리의 `네임스페이스`로 이용된다.<br><br>
  네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능들이 노출된다.<br><br>

2. 모듈 관리<br>
  좀 더 현대적인 충돌 방지 옵션으로는 다양한 의존성 관리를 이용한 `모듈 접근`방법이 있다.<br><br>
  이 도구를 이용하면 어떤 라이브러리들도 식별자를 글로벌 스코프에 추가할 필요없이 특정 스코프로부터 의존성 관리자를 이용해 식별자를 사용할 수 있다.<br><br>

중요한 것은 이러한 것들이 렉시컬 스코프 규칙에서 벗어날 수 있게 하는 것이 아니라 충돌을 방지할 수 있도록 도와주는 것이다.<br>

출처: You don't know JS

