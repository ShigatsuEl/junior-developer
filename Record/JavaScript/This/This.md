# This

[이전 글로 이동하기 -> Module](../Module/Module.md)

### This란 무엇인가?

자바스크립트는 렉시컬 스코프와 동적 스코프의 사이에서 렉시컬 스코프를 채택했다.<br>

렉시컬 스코프는 [Lexical Scope](../Scope/LexicalScope.md) 글에서 다뤘듯이 함수가 어디에서 호출되었는지 상관없이 함수가 선언된 위치에 따라 스코프가 결정되는 것을 말한다.<br>

반대로 동적 스코프는 렉시컬 스코프의 반대되는 개념으로 `함수가 어디서 호출되었는지에 따라 스코프가 결정되는 것`이라 할 수 있다.<br>

자바스크립트는 주로 렉시컬 스코프를 활용하지만 때때로 동적 스코프를 이용해야 하는 경우도 있다.<br>

동적 스코프의 대표적인 예로 **this** 바인딩 객체가 있으며 this는 작성 시점이 아닌 런타임 시점에 스코프가 정해진다.<br>

때문에 this는 함수 선언 위치에 상관없이 어떻게 함수를 호출했는지에 따라 this 바인딩이 결정된다.<br>

요약 -> This는 바인딩 객체로 어디서 선언되었는지에 상관없이 어떻게 호출되었는지에 따라 바인딩 되는 객체이다.<br>

### 호출부

`this`의 바인딩 개념을 이해하기 위해서는 함수가 호출된 부분(호출부)를 확인해봐야 하며 `this가 가리키는 것` 이 무엇인지 확인해야 한다.<br>

호출부는 함수가 호출된 부분을 찾기만 하면 금방 확인할 수 있을 것처럼 보이나 코딩 패턴에 따라 '진짜' 호출부가 어디인지 모호할 때가 많아 확인하기 쉽지 않다.<br>

this는 호출부를 확인하고 다음에 열거할 4가지 규칙 중에 어느 것에 해당하는지 찾게 된다.<br>

- 기본 바인딩

  평범한 함수 호출로 인해 일어나는 바인딩으로 나머지 규칙에 해당하지 않을 경우 적용되는 this의 기본 규칙이다.

  ```
  function foo() {
    console.log(this.a);
  }

  var a = 2;
  foo(); // 2
  ```

  위 코드를 this에 대해 아무것도 모르는 사람이 볼 때 결과값은 undefined가 출력될 것이라고 생각한다.

  결론적으로 결과값은 2가 출력되는 것이 맞다.

  아마도 독자는 foo() 함수의 this는 자기 자신을 가리키기 때문에 foo()함수를 호출하면 this.a(foo.a)는 존재하지 않기 때문에 undefined를 예상하겠지만 실제로는 foo()함수가 호출되었을 당시 전역 객체 window가 this에 바인딩 되었기 때문에 this.a(window.a)를 통해 결과값이 2가 출력이 된다.

  **단독 함수 실행** 은 이와 같이 this를 전역 객체 window에 바인딩한다.

  만약 'use strict(엄격 모드)'가 명시되어 있다면 전역 객체 window가 기본 바인딩 대상에서 제외되기 때문에 this는 undefined가 된다.

  따라서 아래의 결과값은 undefined이다.

  ```
  function foo() {
    'use strict';
    console.log(this.a);
  }

  var a = 2;
  foo(); // 2
  ```

- 암시적 바인딩

  두번째 규칙은 호출부에 컨텍스트 객체가 있는지 확인하는 것이다. 만약 존재한다면 this는 그 객체에 바인딩 된다.

  ```
  function foo() {
    console.log(this.a);
  }

  var obj = {
    a: 2,
    foo
  }

  obj.foo(); // 2
  ```

  기본 바인딩에서는 foo() 자체로 호출되었지만 위 코드에서는 obj.foo()와 같이 호출되었다.

  이와 같이 컨텍스트 객체가 함수를 호출할 시, 바로 이 컨텍스트 객체가 this에 암시(말 하지 않아도)적으로 바인딩 된다.

  따라서 위 코드는 this는 obj가 되고 결과값은 2가 출력이 된다.

  참고) obj1.obj2.foo() 처럼 객체 프로퍼티 참조가 체이닝 된 형태라면 최상위/최하위 수준의 정보만 호출부와 연관된다(여기서는 obj1이 this에 암시적 바인딩)<br><br>

  `암시적 소실`

  암시적으로 바인딩된 함수에서 바인딩이 소실되는 경우가 있다.

  ```
  function foo() {
    console.log(this.a);
  }

  var obj = {
    a: 2,
    foo
  }

  var bar = obj.foo;
  var a = '전역입니다.';
  bar(); // 전역입니다.
  ```

  위의 결과값은 `2`가 출력될 것처럼 보였지만 `전역입니다.`가 출력 됩니다.

  foo함수는 obj객체를 this에 암시적으로 바인딩 했지만 새로운 변수 bar가 참조하고 호출하면서 암시적인 바인딩을 버리고 기본 바인딩을 따르게 된다. 그래서 결과값은 window.bar()에 의해 `전역입니다.`가 출력되는 것이다.

  위와 같이 호출부가 연속해서 바뀌는 경우가 있기 때문에 this 바인딩의 행방이 묘연해지는 경우가 많다.

  때문에 this 바인딩을 어느 값으로 고정하여 this가 현재 무엇을 바인딩하고 있는지 알 수 있다면 굉장히 편리할 것이다.

  그 방법은 다음 규칙이다.
